<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>App/DogTool/bower_components/sails.io.js/sails.io.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Address.html">Address</a></li>
                                <li><a href="../classes/Business_info.html">Business_info</a></li>
                                <li><a href="../classes/Calendar.html">Calendar</a></li>
                                <li><a href="../classes/Charge.html">Charge</a></li>
                                <li><a href="../classes/Consultation.html">Consultation</a></li>
                                <li><a href="../classes/Cost.html">Cost</a></li>
                                <li><a href="../classes/Daycare.html">Daycare</a></li>
                                <li><a href="../classes/Dog.html">Dog</a></li>
                                <li><a href="../classes/dogToolApp.html">dogToolApp</a></li>
                                <li><a href="../classes/FactoryDog.html">FactoryDog</a></li>
                                <li><a href="../classes/Homework.html">Homework</a></li>
                                <li><a href="../classes/Invoice.html">Invoice</a></li>
                                <li><a href="../classes/Note.html">Note</a></li>
                                <li><a href="../classes/Note_Type.html">Note_Type</a></li>
                                <li><a href="../classes/People.html">People</a></li>
                                <li><a href="../classes/People_type.html">People_type</a></li>
                                <li><a href="../classes/Service.html">Service</a></li>
                                <li><a href="../classes/Weight.html">Weight</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/:: Policy.html">:: Policy</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: App/DogTool/bower_components/sails.io.js/sails.io.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * sails.io.js
 * ------------------------------------------------------------------------
 * JavaScript Client (SDK) for communicating with Sails.
 *
 * Note that this script is completely optional, but it is handy if you&#x27;re
 * using WebSockets from the browser to talk to your Sails server.
 *
 * For tips and documentation, visit:
 * http://sailsjs.org/#!documentation/reference/BrowserSDK/BrowserSDK.html
 * ------------------------------------------------------------------------
 *
 * This file allows you to send and receive socket.io messages to &amp; from Sails
 * by simulating a REST client interface on top of socket.io. It models its API
 * after the $.ajax pattern from jQuery you might already be familiar with.
 *
 * So if you&#x27;re switching from using AJAX to sockets, instead of:
 *    &#x60;$.post( url, [data], [cb] )&#x60;
 *
 * You would use:
 *    &#x60;socket.post( url, [data], [cb] )&#x60;
 */


(function() {

  // Save the URL that this script was fetched from for use below.
  // (skip this if this SDK is being used outside of the DOM, i.e. in a Node process)
  var urlThisScriptWasFetchedFrom = (function() {
    if (
      typeof window !== &#x27;object&#x27; ||
      typeof window.document !== &#x27;object&#x27; ||
      typeof window.document.getElementsByTagName !== &#x27;function&#x27;
    ) {
      return &#x27;&#x27;;
    }

    // Return the URL of the last script loaded (i.e. this one)
    // (this must run before nextTick; see http://stackoverflow.com/a/2976714/486547)
    var allScriptsCurrentlyInDOM = window.document.getElementsByTagName(&#x27;script&#x27;);
    var thisScript = allScriptsCurrentlyInDOM[allScriptsCurrentlyInDOM.length - 1];
    return thisScript.src;
  })();

  // Constants
  var CONNECTION_METADATA_PARAMS = {
    version: &#x27;__sails_io_sdk_version&#x27;,
    platform: &#x27;__sails_io_sdk_platform&#x27;,
    language: &#x27;__sails_io_sdk_language&#x27;
  };

  // Current version of this SDK (sailsDK?!?!) and other metadata
  // that will be sent along w/ the initial connection request.
  var SDK_INFO = {
    version: &#x27;0.11.0&#x27;, // TODO: pull this automatically from package.json during build.
    platform: typeof module === &#x27;undefined&#x27; ? &#x27;browser&#x27; : &#x27;node&#x27;,
    language: &#x27;javascript&#x27;
  };
  SDK_INFO.versionString =
    CONNECTION_METADATA_PARAMS.version + &#x27;=&#x27; + SDK_INFO.version + &#x27;&amp;&#x27; +
    CONNECTION_METADATA_PARAMS.platform + &#x27;=&#x27; + SDK_INFO.platform + &#x27;&amp;&#x27; +
    CONNECTION_METADATA_PARAMS.language + &#x27;=&#x27; + SDK_INFO.language;


  // In case you&#x27;re wrapping the socket.io client to prevent pollution of the
  // global namespace, you can pass in your own &#x60;io&#x60; to replace the global one.
  // But we still grab access to the global one if it&#x27;s available here:
  var _io = (typeof io !== &#x27;undefined&#x27;) ? io : null;

  /**
   * Augment the &#x60;io&#x60; object passed in with methods for talking and listening
   * to one or more Sails backend(s).  Automatically connects a socket and
   * exposes it on &#x60;io.socket&#x60;.  If a socket tries to make requests before it
   * is connected, the sails.io.js client will queue it up.
   *
   * @param {SocketIO} io
   */

  function SailsIOClient(io) {

    // Prefer the passed-in &#x60;io&#x60; instance, but also use the global one if we&#x27;ve got it.
    if (!io) {
      io = _io;
    }


    // If the socket.io client is not available, none of this will work.
    if (!io) throw new Error(&#x27;&#x60;sails.io.js&#x60; requires a socket.io client, but &#x60;io&#x60; was not passed in.&#x27;);



    //////////////////////////////////////////////////////////////
    /////                              ///////////////////////////
    ///// PRIVATE METHODS/CONSTRUCTORS ///////////////////////////
    /////                              ///////////////////////////
    //////////////////////////////////////////////////////////////


    /**
     * A little logger for this library to use internally.
     * Basically just a wrapper around &#x60;console.log&#x60; with
     * support for feature-detection.
     *
     * @api private
     * @factory
     */
    function LoggerFactory(options) {
      options = options || {
        prefix: true
      };

      // If &#x60;console.log&#x60; is not accessible, &#x60;log&#x60; is a noop.
      if (
        typeof console !== &#x27;object&#x27; ||
        typeof console.log !== &#x27;function&#x27; ||
        typeof console.log.bind !== &#x27;function&#x27;
      ) {
        return function noop() {};
      }

      return function log() {
        var args = Array.prototype.slice.call(arguments);

        // All logs are disabled when &#x60;io.sails.environment = &#x27;production&#x27;&#x60;.
        if (io.sails.environment === &#x27;production&#x27;) return;

        // Add prefix to log messages (unless disabled)
        var PREFIX = &#x27;&#x27;;
        if (options.prefix) {
          args.unshift(PREFIX);
        }

        // Call wrapped logger
        console.log
          .bind(console)
          .apply(this, args);
      };
    }

    // Create a private logger instance
    var consolog = LoggerFactory();
    consolog.noPrefix = LoggerFactory({
      prefix: false
    });



    /**
     * What is the &#x60;requestQueue&#x60;?
     * 
     * The request queue is used to simplify app-level connection logic--
     * i.e. so you don&#x27;t have to wait for the socket to be connected
     * to start trying to  synchronize data.
     * 
     * @api private
     * @param  {SailsSocket}  socket
     */

    function runRequestQueue (socket) {
      var queue = socket.requestQueue;

      if (!queue) return;
      for (var i in queue) {

        // Double-check that &#x60;queue[i]&#x60; will not
        // inadvertently discover extra properties attached to the Object
        // and/or Array prototype by other libraries/frameworks/tools.
        // (e.g. Ember does this. See https://github.com/balderdashy/sails.io.js/pull/5)
        var isSafeToDereference = ({}).hasOwnProperty.call(queue, i);
        if (isSafeToDereference) {
          // Emit the request.
          _emitFrom(socket, queue[i]);
        }
      }

      // Now empty the queue to remove it as a source of additional complexity.
      queue = null;
    }



    /**
     * Send a JSONP request.
     * 
     * @param  {Object}   opts [optional]
     * @param  {Function} cb
     * @return {XMLHttpRequest}
     */

    function jsonp(opts, cb) {
      opts = opts || {};

      if (typeof window === &#x27;undefined&#x27;) {
        // TODO: refactor node usage to live in here
        return cb();
      }

      var scriptEl = document.createElement(&#x27;script&#x27;);
      window._sailsIoJSConnect = function(response) {
        scriptEl.parentNode.removeChild(scriptEl);
        
        cb(response);
      };
      scriptEl.src = opts.url;
      document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptEl);

    }



    /**
     * The JWR (JSON WebSocket Response) received from a Sails server.
     *
     * @api public
     * @param  {Object}  responseCtx
     *         =&gt; :body
     *         =&gt; :statusCode
     *         =&gt; :headers
     * 
     * @constructor
     */

    function JWR(responseCtx) {
      this.body = responseCtx.body || {};
      this.headers = responseCtx.headers || {};
      this.statusCode = responseCtx.statusCode || 200;
      if (this.statusCode &lt; 200 || this.statusCode &gt;= 400) {
        this.error = this.body || this.statusCode;
      }
    }
    JWR.prototype.toString = function() {
      return &#x27;[ResponseFromSails]&#x27; + &#x27;  -- &#x27; +
        &#x27;Status: &#x27; + this.statusCode + &#x27;  -- &#x27; +
        &#x27;Headers: &#x27; + this.headers + &#x27;  -- &#x27; +
        &#x27;Body: &#x27; + this.body;
    };
    JWR.prototype.toPOJO = function() {
      return {
        body: this.body,
        headers: this.headers,
        statusCode: this.statusCode
      };
    };
    JWR.prototype.pipe = function() {
      // TODO: look at substack&#x27;s stuff
      return new Error(&#x27;Client-side streaming support not implemented yet.&#x27;);
    };


    /**
     * @api private
     * @param  {SailsSocket} socket  [description]
     * @param  {Object} requestCtx [description]
     */

    function _emitFrom(socket, requestCtx) {

      if (!socket._raw) {
        throw new Error(&#x27;Failed to emit from socket- raw SIO socket is missing.&#x27;);
      }

      // Since callback is embedded in requestCtx,
      // retrieve it and delete the key before continuing.
      var cb = requestCtx.cb;
      delete requestCtx.cb;

      // Name of the appropriate socket.io listener on the server
      // ( === the request method or &quot;verb&quot;, e.g. &#x27;get&#x27;, &#x27;post&#x27;, &#x27;put&#x27;, etc. )
      var sailsEndpoint = requestCtx.method;

      socket._raw.emit(sailsEndpoint, requestCtx, function serverResponded(responseCtx) {

        // Send back (emulatedHTTPBody, jsonWebSocketResponse)
        if (cb) {
          cb(responseCtx.body, new JWR(responseCtx));
        }
      });
    }

    //////////////////////////////////////////////////////////////
    ///// &lt;/PRIVATE METHODS/CONSTRUCTORS&gt; ////////////////////////
    //////////////////////////////////////////////////////////////



    // Version note:
    // 
    // &#x60;io.SocketNamespace.prototype&#x60; doesn&#x27;t exist in sio 1.0.
    // 
    // Rather than adding methods to the prototype for the Socket instance that is returned
    // when the browser connects with &#x60;io.connect()&#x60;, we create our own constructor, &#x60;SailsSocket&#x60;.
    // This makes our solution more future-proof and helps us work better w/ the Socket.io team
    // when changes are rolled out in the future.  To get a &#x60;SailsSocket&#x60;, you can run:
    // &#x60;&#x60;&#x60;
    // io.sails.connect();
    // &#x60;&#x60;&#x60;



    /**
     * SailsSocket
     * 
     * A wrapper for an underlying Socket instance that communicates directly
     * to the Socket.io server running inside of Sails.
     *
     * If no &#x60;socket&#x60; option is provied, SailsSocket will function as a mock. It will queue socket
     * requests and event handler bindings, replaying them when the raw underlying socket actually
     * connects. This is handy when we don&#x27;t necessarily have the valid configuration to know
     * WHICH SERVER to talk to yet, etc.  It is also used by &#x60;io.socket&#x60; for your convenience.
     * 
     * @constructor
     */
    
    function SailsSocket (opts){
      var self = this;
      opts = opts||{};

      // Absorb opts
      self.useCORSRouteToGetCookie = opts.useCORSRouteToGetCookie;
      self.url = opts.url;
      self.multiplex = opts.multiplex;
      self.transports = opts.transports;

      // Set up &quot;eventQueue&quot; to hold event handlers which have not been set on the actual raw socket yet.
      self.eventQueue = {};

      // Listen for special &#x60;parseError&#x60; event sent from sockets hook on the backend
      // if an error occurs but a valid callback was not received from the client
      // (i.e. so the server had no other way to send back the error information)
      self.on(&#x27;sails:parseError&#x27;, function (err){
        consolog(&#x27;Sails encountered an error parsing a socket message sent from this client, and did not have access to a callback function to respond with.&#x27;);
        consolog(&#x27;Error details:&#x27;,err);
      });

      // TODO:
      // Listen for a special private message on any connected that allows the server
      // to set the environment (giving us 100% certainty that we guessed right)
      // However, note that the &#x60;console.log&#x60;s called before and after connection
      // are still forced to rely on our existing heuristics (to disable, tack #production
      // onto the URL used to fetch this file.)
    }


    /**
     * Start connecting this socket.
     * 
     * @api private
     */
    SailsSocket.prototype._connect = function (){
      var self = this;

      // Apply &#x60;io.sails&#x60; config as defaults
      // (now that at least one tick has elapsed)
      self.useCORSRouteToGetCookie = self.useCORSRouteToGetCookie||io.sails.useCORSRouteToGetCookie;
      self.url = self.url||io.sails.url;
      self.transports = self.transports || io.sails.transports;

      // Ensure URL has no trailing slash
      self.url = self.url ? self.url.replace(/(\/)$/, &#x27;&#x27;) : undefined;

      // Mix the current SDK version into the query string in
      // the connection request to the server:
      if (typeof self.query !== &#x27;string&#x27;) self.query = SDK_INFO.versionString;
      else self.query += &#x27;&amp;&#x27; + SDK_INFO.versionString;

      // Determine whether this is a cross-origin socket by examining the
      // hostname and port on the &#x60;window.location&#x60; object.
      var isXOrigin = (function (){

        // If &#x60;window&#x60; doesn&#x27;t exist (i.e. being used from node.js), then it&#x27;s
        // always &quot;cross-domain&quot;.
        if (typeof window === &#x27;undefined&#x27; || typeof window.location === &#x27;undefined&#x27;) {
          return false;
        }

        // If &#x60;self.url&#x60; (aka &quot;target&quot;) is falsy, then we don&#x27;t need to worry about it.
        if (typeof self.url !== &#x27;string&#x27;) { return false; }
        
        // Get information about the &quot;target&quot; (&#x60;self.url&#x60;)
        var targetProtocol = (function (){
          try {
            targetProtocol = self.url.match(/^([a-z]+:\/\/)/i)[1].toLowerCase();
          }
          catch (e) {}
          targetProtocol = targetProtocol || &#x27;http://&#x27;;
          return targetProtocol;
        })();
        var isTargetSSL = !!self.url.match(&#x27;^https&#x27;);
        var targetPort = (function (){
          try {
            return self.url.match(/^[a-z]+:\/\/[^:]*:([0-9]*)/i)[1];
          }
          catch (e){}
          return isTargetSSL ? &#x27;443&#x27; : &#x27;80&#x27;;
        })();
        var targetAfterProtocol = self.url.replace(/^([a-z]+:\/\/)/i, &#x27;&#x27;);


        // If target protocol is different than the actual protocol,
        // then we&#x27;ll consider this cross-origin.
        if (targetProtocol.replace(/[:\/]/g, &#x27;&#x27;) !== window.location.protocol.replace(/[:\/]/g,&#x27;&#x27;)) {
          return true;
        }


        // If target hostname is different than actual hostname, we&#x27;ll consider this cross-origin.
        var hasSameHostname = targetAfterProtocol.search(window.location.hostname) !== 0;
        if (!hasSameHostname) {
          return true;
        }

        // If no actual port is explicitly set on the &#x60;window.location&#x60; object,
        // we&#x27;ll assume either 80 or 443.
        var isLocationSSL = window.location.protocol.match(/https/i);
        var locationPort = (window.location.port+&#x27;&#x27;) || (isLocationSSL ? &#x27;443&#x27; : &#x27;80&#x27;);

        // Finally, if ports don&#x27;t match, we&#x27;ll consider this cross-origin.
        if (targetPort !== locationPort) {
          return true;
        }

        // Otherwise, it&#x27;s the same origin.
        return false;

      })();


      // Prepare to start connecting the socket
      (function selfInvoking (cb){

        // If this is an attempt at a cross-origin or cross-port
        // socket connection, send a JSONP request first to ensure
        // that a valid cookie is available.  This can be disabled
        // by setting &#x60;io.sails.useCORSRouteToGetCookie&#x60; to false.
        // 
        // Otherwise, skip the stuff below.
        if (!(self.useCORSRouteToGetCookie &amp;&amp; isXOrigin)) {
          return cb();
        }

        // Figure out the x-origin CORS route
        // (Sails provides a default)
        var xOriginCookieURL = self.url;
        if (typeof self.useCORSRouteToGetCookie === &#x27;string&#x27;) {
          xOriginCookieURL += self.useCORSRouteToGetCookie;
        }
        else {
          xOriginCookieURL += &#x27;/__getcookie&#x27;;
        }


        // Make the AJAX request (CORS)
        if (typeof window !== &#x27;undefined&#x27;) {
          jsonp({
            url: xOriginCookieURL,
            method: &#x27;GET&#x27;
          }, cb);
          return;
        }

        // If there&#x27;s no &#x60;window&#x60; object, we must be running in Node.js
        // so just require the request module and send the HTTP request that
        // way.
        var mikealsReq = require(&#x27;request&#x27;);
        mikealsReq.get(xOriginCookieURL, function(err, httpResponse, body) {
          if (err) {
            consolog(
              &#x27;Failed to connect socket (failed to get cookie)&#x27;,
              &#x27;Error:&#x27;, err
            );
            return;
          }
          cb();
        });

      })(function goAheadAndActuallyConnect() {

        // Now that we&#x27;re ready to connect, create a raw underlying Socket
        // using Socket.io and save it as &#x60;_raw&#x60; (this will start it connecting)
        self._raw = io(self.url, self);

        // Replay event bindings from the eager socket
        self.replay();


        /**
         * &#x27;connect&#x27; event is triggered when the socket establishes a connection
         *  successfully.
         */
        self.on(&#x27;connect&#x27;, function socketConnected() {

          consolog.noPrefix(
            &#x27;\n&#x27; +
            &#x27;\n&#x27; +
            // &#x27;    |&gt;    &#x27; + &#x27;\n&#x27; +
            // &#x27;  \\___/  &#x27;+️
            // &#x27;\n&#x27;+
             &#x27;  |&gt;    Now connected to Sails.&#x27; + &#x27;\n&#x27; +
            &#x27;\\___/   For help, see: http://bit.ly/1DmTvgK&#x27; + &#x27;\n&#x27; +
             &#x27;        (using &#x27;+io.sails.sdk.platform+&#x27; SDK @v&#x27;+io.sails.sdk.version+&#x27;)&#x27;+ &#x27;\n&#x27; +
            &#x27;\n&#x27;+
            &#x27;\n&#x27;+
            // &#x27;\n&#x27;+
            &#x27;&#x27;
            // &#x27; ⚓︎ (development mode)&#x27;
            // &#x27;e.g. to send a GET request to Sails via WebSockets, run:&#x27;+ &#x27;\n&#x27; +
            // &#x27;&#x60;io.socket.get(&quot;/foo&quot;, function serverRespondedWith (body, jwr) { console.log(body); })&#x60;&#x27;+ &#x27;\n&#x27; +
          );
        });
        
        self.on(&#x27;disconnect&#x27;, function() {
          self.connectionLostTimestamp = (new Date()).getTime();
          consolog(&#x27;====================================&#x27;);
          consolog(&#x27;Socket was disconnected from Sails.&#x27;);
          consolog(&#x27;Usually, this is due to one of the following reasons:&#x27; + &#x27;\n&#x27; +
            &#x27; -&gt; the server &#x27; + (self.url ? self.url + &#x27; &#x27; : &#x27;&#x27;) + &#x27;was taken down&#x27; + &#x27;\n&#x27; +
            &#x27; -&gt; your browser lost internet connectivity&#x27;);
          consolog(&#x27;====================================&#x27;);
        });

        self.on(&#x27;reconnecting&#x27;, function(numAttempts) {
          consolog(
            &#x27;\n&#x27;+
            &#x27;        Socket is trying to reconnect to Sails...\n&#x27;+
            &#x27;_-|&gt;_-  (attempt #&#x27; + numAttempts + &#x27;)&#x27;+&#x27;\n&#x27;+
            &#x27;\n&#x27;
          );
        });
      
        self.on(&#x27;reconnect&#x27;, function(transport, numAttempts) {
          var msSinceConnectionLost = ((new Date()).getTime() - self.connectionLostTimestamp);
          var numSecsOffline = (msSinceConnectionLost / 1000);
          consolog(
            &#x27;\n&#x27;+
             &#x27;  |&gt;    Socket reconnected successfully after&#x27;+&#x27;\n&#x27;+
            &#x27;\\___/   being offline for ~&#x27; + numSecsOffline + &#x27; seconds.&#x27;+&#x27;\n&#x27;+
            &#x27;\n&#x27;
          );
        });
      
        // &#x27;error&#x27; event is triggered if connection can not be established.
        // (usually because of a failed authorization, which is in turn
        // usually due to a missing or invalid cookie)
        self.on(&#x27;error&#x27;, function failedToConnect(err) {

          // TODO:
          // handle failed connections due to failed authorization
          // in a smarter way (probably can listen for a different event)

          // A bug in Socket.io 0.9.x causes &#x60;connect_failed&#x60;
          // and &#x60;reconnect_failed&#x60; not to fire.
          // Check out the discussion in github issues for details:
          // https://github.com/LearnBoost/socket.io/issues/652
          // io.socket.on(&#x27;connect_failed&#x27;, function () {
          //  consolog(&#x27;io.socket emitted &#x60;connect_failed&#x60;&#x27;);
          // });
          // io.socket.on(&#x27;reconnect_failed&#x27;, function () {
          //  consolog(&#x27;io.socket emitted &#x60;reconnect_failed&#x60;&#x27;);
          // });

          consolog(
            &#x27;Failed to connect socket (probably due to failed authorization on server)&#x27;,
            &#x27;Error:&#x27;, err
          );
        });
      });

    };


    /**
     * Disconnect the underlying socket.
     *
     * @api public
     */
    SailsSocket.prototype.disconnect = function (){
      if (!this._raw) {
        throw new Error(&#x27;Cannot disconnect- socket is already disconnected&#x27;);
      }
      return this._raw.disconnect();
    };



    /**
     * isConnected
     *
     * @api private
     * @return {Boolean} whether the socket is connected and able to
     *                           communicate w/ the server.
     */

    SailsSocket.prototype.isConnected = function () {
      if (!this._raw) {
        return false;
      }

      return !!this._raw.connected;
    };



    /**
     * [replay description]
     * @return {[type]} [description]
     */
    SailsSocket.prototype.replay = function (){
      var self = this;

      // Pass events and a reference to the request queue
      // off to the self._raw for consumption
      for (var evName in self.eventQueue) {
        for (var i in self.eventQueue[evName]) {
          self._raw.on(evName, self.eventQueue[evName][i]);
        }
      }

      // Bind a one-time function to run the request queue
      // when the self._raw connects.
      if ( !self.isConnected() ) {
        var alreadyRanRequestQueue = false;
        self._raw.on(&#x27;connect&#x27;, function whenRawSocketConnects() {
          if (alreadyRanRequestQueue) return;
          runRequestQueue(self);
          alreadyRanRequestQueue = true;
        });
      }
      // Or run it immediately if self._raw is already connected
      else {
        runRequestQueue(self);
      }

      return self;
    };


    /**
     * Chainable method to bind an event to the socket.
     * 
     * @param  {String}   evName [event name]
     * @param  {Function} fn     [event handler function]
     * @return {SailsSocket}
     */
    SailsSocket.prototype.on = function (evName, fn){

      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.on(evName, fn);
        return this;
      }

      // Otherwise queue the event binding.
      if (!this.eventQueue[evName]) {
        this.eventQueue[evName] = [fn];
      }
      else {
        this.eventQueue[evName].push(fn);
      }

      return this;
    };

    /**
     * Chainable method to unbind an event from the socket.
     * 
     * @param  {String}   evName [event name]
     * @param  {Function} fn     [event handler function]
     * @return {SailsSocket}
     */
    SailsSocket.prototype.off = function (evName, fn){

      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.off(evName, fn);
        return this;
      }

      // Otherwise queue the event binding.
      if (this.eventQueue[evName] &amp;&amp; this.eventQueue[evName].indexOf(fn) &gt; -1) {
        this.eventQueue[evName].splice(this.eventQueue[evName].indexOf(fn), 1);
      }

      return this;
    };


    /**
     * Chainable method to unbind all events from the socket.
     * 
     * @return {SailsSocket}
     */
    SailsSocket.prototype.removeAllListeners = function (){

      // Bind the event to the raw underlying socket if possible.
      if (this._raw) {
        this._raw.removeAllListeners();
        return this;
      }

      // Otherwise queue the event binding.
      this.eventQueue = {};
      
      return this;
    };

    /**
     * Simulate a GET request to sails
     * e.g.
     *    &#x60;socket.get(&#x27;/user/3&#x27;, Stats.populate)&#x60;
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} params ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.get = function(url, data, cb) {

      // &#x60;data&#x60; is optional
      if (typeof data === &#x27;function&#x27;) {
        cb = data;
        data = {};
      }

      return this.request({
        method: &#x27;get&#x27;,
        params: data,
        url: url
      }, cb);
    };



    /**
     * Simulate a POST request to sails
     * e.g.
     *    &#x60;socket.post(&#x27;/event&#x27;, newMeeting, $spinner.hide)&#x60;
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} params ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.post = function(url, data, cb) {

      // &#x60;data&#x60; is optional
      if (typeof data === &#x27;function&#x27;) {
        cb = data;
        data = {};
      }

      return this.request({
        method: &#x27;post&#x27;,
        data: data,
        url: url
      }, cb);
    };



    /**
     * Simulate a PUT request to sails
     * e.g.
     *    &#x60;socket.post(&#x27;/event/3&#x27;, changedFields, $spinner.hide)&#x60;
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} params ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype.put = function(url, data, cb) {

      // &#x60;data&#x60; is optional
      if (typeof data === &#x27;function&#x27;) {
        cb = data;
        data = {};
      }

      return this.request({
        method: &#x27;put&#x27;,
        params: data,
        url: url
      }, cb);
    };



    /**
     * Simulate a DELETE request to sails
     * e.g.
     *    &#x60;socket.delete(&#x27;/event&#x27;, $spinner.hide)&#x60;
     *
     * @api public
     * @param {String} url    ::    destination URL
     * @param {Object} params ::    parameters to send with the request [optional]
     * @param {Function} cb   ::    callback function to call when finished [optional]
     */

    SailsSocket.prototype[&#x27;delete&#x27;] = function(url, data, cb) {

      // &#x60;data&#x60; is optional
      if (typeof data === &#x27;function&#x27;) {
        cb = data;
        data = {};
      }

      return this.request({
        method: &#x27;delete&#x27;,
        params: data,
        url: url
      }, cb);
    };



    /**
     * Simulate an HTTP request to sails
     * e.g.
     * &#x60;&#x60;&#x60;
     * socket.request({
     *   url:&#x27;/user&#x27;,
     *   params: {},
     *   method: &#x27;POST&#x27;,
     *   headers: {}
     * }, function (responseBody, JWR) {
     *   // ...
     * });
     * &#x60;&#x60;&#x60;
     *
     * @api public
     * @option {String} url    ::    destination URL
     * @option {Object} params ::    parameters to send with the request [optional]
     * @option {Object} headers::    headers to send with the request [optional]
     * @option {Function} cb   ::    callback function to call when finished [optional]
     * @option {String} method ::    HTTP request method [optional]
     */

    SailsSocket.prototype.request = function(options, cb) {

      var usage =
      &#x27;Usage:\n&#x27;+
      &#x27;socket.request( options, [fnToCallWhenComplete] )\n\n&#x27;+
      &#x27;options.url :: e.g. &quot;/foo/bar&quot;&#x27;+&#x27;\n&#x27;+
      &#x27;options.method :: e.g. &quot;get&quot;, &quot;post&quot;, &quot;put&quot;, or &quot;delete&quot;, etc.&#x27;+&#x27;\n&#x27;+
      &#x27;options.params :: e.g. { emailAddress: &quot;mike@sailsjs.org&quot; }&#x27;+&#x27;\n&#x27;+
      &#x27;options.headers :: e.g. { &quot;x-my-custom-header&quot;: &quot;some string&quot; }&#x27;;
      // Old usage:
      // var usage = &#x27;Usage:\n socket.&#x27;+(options.method||&#x27;request&#x27;)+&#x27;(&#x27;+
      //   &#x27; destinationURL, [dataToSend], [fnToCallWhenComplete] )&#x27;;


      // Validate options and callback
      if (typeof options !== &#x27;object&#x27; || typeof options.url !== &#x27;string&#x27;) {
        throw new Error(&#x27;Invalid or missing URL!\n&#x27; + usage);
      }
      if (options.method &amp;&amp; typeof options.method !== &#x27;string&#x27;) {
        throw new Error(&#x27;Invalid &#x60;method&#x60; provided (should be a string like &quot;post&quot; or &quot;put&quot;)\n&#x27; + usage);
      }
      if (options.headers &amp;&amp; typeof options.headers !== &#x27;object&#x27;) {
        throw new Error(&#x27;Invalid &#x60;headers&#x60; provided (should be an object with string values)\n&#x27; + usage);
      }
      if (options.params &amp;&amp; typeof options.params !== &#x27;object&#x27;) {
        throw new Error(&#x27;Invalid &#x60;params&#x60; provided (should be an object with string values)\n&#x27; + usage);
      }
      if (cb &amp;&amp; typeof cb !== &#x27;function&#x27;) {
        throw new Error(&#x27;Invalid callback function!\n&#x27; + usage);
      }
      

      // Build a simulated request object
      // (and sanitize/marshal options along the way)
      var requestCtx = {

        method: options.method.toLowerCase() || &#x27;get&#x27;,

        headers: options.headers || {},

        data: options.params || options.data || {},

        // Remove trailing slashes and spaces to make packets smaller.
        url: options.url.replace(/^(.+)\/*\s*$/, &#x27;$1&#x27;),

        cb: cb
      };

      // If this socket is not connected yet, queue up this request
      // instead of sending it.
      // (so it can be replayed when the socket comes online.)
      if ( ! this.isConnected() ) {

        // If no queue array exists for this socket yet, create it.
        this.requestQueue = this.requestQueue || [];
        this.requestQueue.push(requestCtx);
        return;
      }


      // Otherwise, our socket is ok!
      // Send the request.
      _emitFrom(this, requestCtx);
    };



    /**
     * Socket.prototype._request
     *
     * Simulate HTTP over Socket.io.
     *
     * @api private
     * @param  {[type]}   options [description]
     * @param  {Function} cb      [description]
     */
    SailsSocket.prototype._request = function(options, cb) {
      throw new Error(&#x27;&#x60;_request()&#x60; was a private API deprecated as of v0.11 of the sails.io.js client. Use &#x60;.request()&#x60; instead.&#x27;);
    };



    // Set a &#x60;sails&#x60; object that may be used for configuration before the
    // first socket connects (i.e. to prevent auto-connect)
    io.sails = {

      // Whether to automatically connect a socket and save it as &#x60;io.socket&#x60;.
      autoConnect: true,

      // The route (path) to hit to get a x-origin (CORS) cookie
      // (or true to use the default: &#x27;/__getcookie&#x27;)
      useCORSRouteToGetCookie: true,

      // The environment we&#x27;re running in.
      // (logs are not displayed when this is set to &#x27;production&#x27;)
      // 
      // Defaults to development unless this script was fetched from a URL
      // that ends in &#x60;*.min.js&#x60; or &#x27;#production&#x27; (may also be manually overridden.)
      // 
      environment: urlThisScriptWasFetchedFrom.match(/(\#production|\.min\.js)/g) ? &#x27;production&#x27; : &#x27;development&#x27;,

      // The version of this sails.io.js client SDK
      sdk: SDK_INFO,

      // Transports to use when communicating with the server, in the order they will be tried
      transports: [&#x27;polling&#x27;, &#x27;websocket&#x27;]
    };



    /**
     * Add &#x60;io.sails.connect&#x60; function as a wrapper for the built-in &#x60;io()&#x60; aka &#x60;io.connect()&#x60;
     * method, returning a SailsSocket. This special function respects the configured io.sails
     * connection URL, as well as sending other identifying information (most importantly, the
     * current version of this SDK).
     *
     * @param  {String} url  [optional]
     * @param  {Object} opts [optional]
     * @return {Socket}
     */
    io.sails.connect = function(url, opts) {
      opts = opts || {};

      // If explicit connection url is specified, save it to options
      opts.url = url || opts.url || undefined;

      // Instantiate and return a new SailsSocket- and try to connect immediately.
      var socket = new SailsSocket(opts);
      socket._connect();
      return socket;
    };



    // io.socket
    // 
    // The eager instance of Socket which will automatically try to connect
    // using the host that this js file was served from.
    // 
    // This can be disabled or configured by setting properties on &#x60;io.sails.*&#x60; within the
    // first cycle of the event loop.
    // 

    
    // Build &#x60;io.socket&#x60; so it exists
    // (this does not start the connection process)
    io.socket = new SailsSocket();

    // In the mean time, this eager socket will be queue events bound by the user
    // before the first cycle of the event loop (using &#x60;.on()&#x60;), which will later
    // be rebound on the raw underlying socket.

    // If configured to do so, start auto-connecting after the first cycle of the event loop
    // has completed (to allow time for this behavior to be configured/disabled
    // by specifying properties on &#x60;io.sails&#x60;)
    setTimeout(function() {

      // If autoConnect is disabled, delete the eager socket (io.socket) and bail out.
      if (!io.sails.autoConnect) {
        delete io.socket;
        return;
      }

      // consolog(&#x27;Eagerly auto-connecting socket to Sails... (requests will be queued in the mean-time)&#x27;);
      io.socket._connect();


    }, 0); // &lt;/setTimeout&gt;


    // Return the &#x60;io&#x60; object.
    return io;
  }


  // Add CommonJS support to allow this client SDK to be used from Node.js.
  if (typeof module === &#x27;object&#x27; &amp;&amp; typeof module.exports !== &#x27;undefined&#x27;) {
    module.exports = SailsIOClient;
    return SailsIOClient;
  }

  // Otherwise, try to instantiate the client:
  // In case you&#x27;re wrapping the socket.io client to prevent pollution of the
  // global namespace, you can replace the global &#x60;io&#x60; with your own &#x60;io&#x60; here:
  return SailsIOClient();

})();

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
