<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>App/DogTool/bower_components/angular-touch/angular-touch.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/Address.html">Address</a></li>
                                <li><a href="../classes/Business_info.html">Business_info</a></li>
                                <li><a href="../classes/Calendar.html">Calendar</a></li>
                                <li><a href="../classes/Charge.html">Charge</a></li>
                                <li><a href="../classes/Consultation.html">Consultation</a></li>
                                <li><a href="../classes/Cost.html">Cost</a></li>
                                <li><a href="../classes/Daycare.html">Daycare</a></li>
                                <li><a href="../classes/Dog.html">Dog</a></li>
                                <li><a href="../classes/dogToolApp.html">dogToolApp</a></li>
                                <li><a href="../classes/FactoryDog.html">FactoryDog</a></li>
                                <li><a href="../classes/Homework.html">Homework</a></li>
                                <li><a href="../classes/Invoice.html">Invoice</a></li>
                                <li><a href="../classes/Note.html">Note</a></li>
                                <li><a href="../classes/Note_Type.html">Note_Type</a></li>
                                <li><a href="../classes/People.html">People</a></li>
                                <li><a href="../classes/People_type.html">People_type</a></li>
                                <li><a href="../classes/Service.html">Service</a></li>
                                <li><a href="../classes/Weight.html">Weight</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/:: Policy.html">:: Policy</a></li>
                                <li><a href="../modules/ng.html">ng</a></li>
                                <li><a href="../modules/ngMock.html">ngMock</a></li>
                                <li><a href="../modules/ngMockE2E.html">ngMockE2E</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: App/DogTool/bower_components/angular-touch/angular-touch.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * @license AngularJS v1.3.13
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
(function(window, angular, undefined) {&#x27;use strict&#x27;;

/**
 * @ngdoc module
 * @name ngTouch
 * @description
 *
 * # ngTouch
 *
 * The &#x60;ngTouch&#x60; module provides touch events and other helpers for touch-enabled devices.
 * The implementation is based on jQuery Mobile touch event handling
 * ([jquerymobile.com](http://jquerymobile.com/)).
 *
 *
 * See {@link ngTouch.$swipe &#x60;$swipe&#x60;} for usage.
 *
 * &lt;div doc-module-components=&quot;ngTouch&quot;&gt;&lt;/div&gt;
 *
 */

// define ngTouch module
/* global -ngTouch */
var ngTouch = angular.module(&#x27;ngTouch&#x27;, []);

/* global ngTouch: false */

    /**
     * @ngdoc service
     * @name $swipe
     *
     * @description
     * The &#x60;$swipe&#x60; service is a service that abstracts the messier details of hold-and-drag swipe
     * behavior, to make implementing swipe-related directives more convenient.
     *
     * Requires the {@link ngTouch &#x60;ngTouch&#x60;} module to be installed.
     *
     * &#x60;$swipe&#x60; is used by the &#x60;ngSwipeLeft&#x60; and &#x60;ngSwipeRight&#x60; directives in &#x60;ngTouch&#x60;, and by
     * &#x60;ngCarousel&#x60; in a separate component.
     *
     * # Usage
     * The &#x60;$swipe&#x60; service is an object with a single method: &#x60;bind&#x60;. &#x60;bind&#x60; takes an element
     * which is to be watched for swipes, and an object with four handler functions. See the
     * documentation for &#x60;bind&#x60; below.
     */

ngTouch.factory(&#x27;$swipe&#x27;, [function() {
  // The total distance in any direction before we make the call on swipe vs. scroll.
  var MOVE_BUFFER_RADIUS = 10;

  var POINTER_EVENTS = {
    &#x27;mouse&#x27;: {
      start: &#x27;mousedown&#x27;,
      move: &#x27;mousemove&#x27;,
      end: &#x27;mouseup&#x27;
    },
    &#x27;touch&#x27;: {
      start: &#x27;touchstart&#x27;,
      move: &#x27;touchmove&#x27;,
      end: &#x27;touchend&#x27;,
      cancel: &#x27;touchcancel&#x27;
    }
  };

  function getCoordinates(event) {
    var touches = event.touches &amp;&amp; event.touches.length ? event.touches : [event];
    var e = (event.changedTouches &amp;&amp; event.changedTouches[0]) ||
        (event.originalEvent &amp;&amp; event.originalEvent.changedTouches &amp;&amp;
            event.originalEvent.changedTouches[0]) ||
        touches[0].originalEvent || touches[0];

    return {
      x: e.clientX,
      y: e.clientY
    };
  }

  function getEvents(pointerTypes, eventType) {
    var res = [];
    angular.forEach(pointerTypes, function(pointerType) {
      var eventName = POINTER_EVENTS[pointerType][eventType];
      if (eventName) {
        res.push(eventName);
      }
    });
    return res.join(&#x27; &#x27;);
  }

  return {
    /**
     * @ngdoc method
     * @name $swipe#bind
     *
     * @description
     * The main method of &#x60;$swipe&#x60;. It takes an element to be watched for swipe motions, and an
     * object containing event handlers.
     * The pointer types that should be used can be specified via the optional
     * third argument, which is an array of strings &#x60;&#x27;mouse&#x27;&#x60; and &#x60;&#x27;touch&#x27;&#x60;. By default,
     * &#x60;$swipe&#x60; will listen for &#x60;mouse&#x60; and &#x60;touch&#x60; events.
     *
     * The four events are &#x60;start&#x60;, &#x60;move&#x60;, &#x60;end&#x60;, and &#x60;cancel&#x60;. &#x60;start&#x60;, &#x60;move&#x60;, and &#x60;end&#x60;
     * receive as a parameter a coordinates object of the form &#x60;{ x: 150, y: 310 }&#x60;.
     *
     * &#x60;start&#x60; is called on either &#x60;mousedown&#x60; or &#x60;touchstart&#x60;. After this event, &#x60;$swipe&#x60; is
     * watching for &#x60;touchmove&#x60; or &#x60;mousemove&#x60; events. These events are ignored until the total
     * distance moved in either dimension exceeds a small threshold.
     *
     * Once this threshold is exceeded, either the horizontal or vertical delta is greater.
     * - If the horizontal distance is greater, this is a swipe and &#x60;move&#x60; and &#x60;end&#x60; events follow.
     * - If the vertical distance is greater, this is a scroll, and we let the browser take over.
     *   A &#x60;cancel&#x60; event is sent.
     *
     * &#x60;move&#x60; is called on &#x60;mousemove&#x60; and &#x60;touchmove&#x60; after the above logic has determined that
     * a swipe is in progress.
     *
     * &#x60;end&#x60; is called when a swipe is successfully completed with a &#x60;touchend&#x60; or &#x60;mouseup&#x60;.
     *
     * &#x60;cancel&#x60; is called either on a &#x60;touchcancel&#x60; from the browser, or when we begin scrolling
     * as described above.
     *
     */
    bind: function(element, eventHandlers, pointerTypes) {
      // Absolute total movement, used to control swipe vs. scroll.
      var totalX, totalY;
      // Coordinates of the start position.
      var startCoords;
      // Last event&#x27;s position.
      var lastPos;
      // Whether a swipe is active.
      var active = false;

      pointerTypes = pointerTypes || [&#x27;mouse&#x27;, &#x27;touch&#x27;];
      element.on(getEvents(pointerTypes, &#x27;start&#x27;), function(event) {
        startCoords = getCoordinates(event);
        active = true;
        totalX = 0;
        totalY = 0;
        lastPos = startCoords;
        eventHandlers[&#x27;start&#x27;] &amp;&amp; eventHandlers[&#x27;start&#x27;](startCoords, event);
      });
      var events = getEvents(pointerTypes, &#x27;cancel&#x27;);
      if (events) {
        element.on(events, function(event) {
          active = false;
          eventHandlers[&#x27;cancel&#x27;] &amp;&amp; eventHandlers[&#x27;cancel&#x27;](event);
        });
      }

      element.on(getEvents(pointerTypes, &#x27;move&#x27;), function(event) {
        if (!active) return;

        // Android will send a touchcancel if it thinks we&#x27;re starting to scroll.
        // So when the total distance (+ or - or both) exceeds 10px in either direction,
        // we either:
        // - On totalX &gt; totalY, we send preventDefault() and treat this as a swipe.
        // - On totalY &gt; totalX, we let the browser handle it as a scroll.

        if (!startCoords) return;
        var coords = getCoordinates(event);

        totalX += Math.abs(coords.x - lastPos.x);
        totalY += Math.abs(coords.y - lastPos.y);

        lastPos = coords;

        if (totalX &lt; MOVE_BUFFER_RADIUS &amp;&amp; totalY &lt; MOVE_BUFFER_RADIUS) {
          return;
        }

        // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.
        if (totalY &gt; totalX) {
          // Allow native scrolling to take over.
          active = false;
          eventHandlers[&#x27;cancel&#x27;] &amp;&amp; eventHandlers[&#x27;cancel&#x27;](event);
          return;
        } else {
          // Prevent the browser from scrolling.
          event.preventDefault();
          eventHandlers[&#x27;move&#x27;] &amp;&amp; eventHandlers[&#x27;move&#x27;](coords, event);
        }
      });

      element.on(getEvents(pointerTypes, &#x27;end&#x27;), function(event) {
        if (!active) return;
        active = false;
        eventHandlers[&#x27;end&#x27;] &amp;&amp; eventHandlers[&#x27;end&#x27;](getCoordinates(event), event);
      });
    }
  };
}]);

/* global ngTouch: false */

/**
 * @ngdoc directive
 * @name ngClick
 *
 * @description
 * A more powerful replacement for the default ngClick designed to be used on touchscreen
 * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending
 * the click event. This version handles them immediately, and then prevents the
 * following click event from propagating.
 *
 * Requires the {@link ngTouch &#x60;ngTouch&#x60;} module to be installed.
 *
 * This directive can fall back to using an ordinary click event, and so works on desktop
 * browsers as well as mobile.
 *
 * This directive also sets the CSS class &#x60;ng-click-active&#x60; while the element is being held
 * down (by a mouse click or touch) so you can restyle the depressed element if you wish.
 *
 * @element ANY
 * @param {expression} ngClick {@link guide/expression Expression} to evaluate
 * upon tap. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
    &lt;example module=&quot;ngClickExample&quot; deps=&quot;angular-touch.js&quot;&gt;
      &lt;file name=&quot;index.html&quot;&gt;
        &lt;button ng-click=&quot;count = count + 1&quot; ng-init=&quot;count=0&quot;&gt;
          Increment
        &lt;/button&gt;
        count: {{ count }}
      &lt;/file&gt;
      &lt;file name=&quot;script.js&quot;&gt;
        angular.module(&#x27;ngClickExample&#x27;, [&#x27;ngTouch&#x27;]);
      &lt;/file&gt;
    &lt;/example&gt;
 */

ngTouch.config([&#x27;$provide&#x27;, function($provide) {
  $provide.decorator(&#x27;ngClickDirective&#x27;, [&#x27;$delegate&#x27;, function($delegate) {
    // drop the default ngClick directive
    $delegate.shift();
    return $delegate;
  }]);
}]);

ngTouch.directive(&#x27;ngClick&#x27;, [&#x27;$parse&#x27;, &#x27;$timeout&#x27;, &#x27;$rootElement&#x27;,
    function($parse, $timeout, $rootElement) {
  var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.
  var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.
  var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click
  var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.

  var ACTIVE_CLASS_NAME = &#x27;ng-click-active&#x27;;
  var lastPreventedTime;
  var touchCoordinates;
  var lastLabelClickCoordinates;


  // TAP EVENTS AND GHOST CLICKS
  //
  // Why tap events?
  // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you&#x27;re
  // double-tapping, and then fire a click event.
  //
  // This delay sucks and makes mobile apps feel unresponsive.
  // So we detect touchstart, touchmove, touchcancel and touchend ourselves and determine when
  // the user has tapped on something.
  //
  // What happens when the browser then generates a click event?
  // The browser, of course, also detects the tap and fires a click after a delay. This results in
  // tapping/clicking twice. We do &quot;clickbusting&quot; to prevent it.
  //
  // How does it work?
  // We attach global touchstart and click handlers, that run during the capture (early) phase.
  // So the sequence for a tap is:
  // - global touchstart: Sets an &quot;allowable region&quot; at the point touched.
  // - element&#x27;s touchstart: Starts a touch
  // (- touchmove or touchcancel ends the touch, no click follows)
  // - element&#x27;s touchend: Determines if the tap is valid (didn&#x27;t move too far away, didn&#x27;t hold
  //   too long) and fires the user&#x27;s tap handler. The touchend also calls preventGhostClick().
  // - preventGhostClick() removes the allowable region the global touchstart created.
  // - The browser generates a click event.
  // - The global click handler catches the click, and checks whether it was in an allowable region.
  //     - If preventGhostClick was called, the region will have been removed, the click is busted.
  //     - If the region is still there, the click proceeds normally. Therefore clicks on links and
  //       other elements without ngTap on them work normally.
  //
  // This is an ugly, terrible hack!
  // Yeah, tell me about it. The alternatives are using the slow click events, or making our users
  // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular
  // encapsulates this ugly logic away from the user.
  //
  // Why not just put click handlers on the element?
  // We do that too, just to be sure. If the tap event caused the DOM to change,
  // it is possible another element is now in that position. To take account for these possibly
  // distinct elements, the handlers are global and care only about coordinates.

  // Checks if the coordinates are close enough to be within the region.
  function hit(x1, y1, x2, y2) {
    return Math.abs(x1 - x2) &lt; CLICKBUSTER_THRESHOLD &amp;&amp; Math.abs(y1 - y2) &lt; CLICKBUSTER_THRESHOLD;
  }

  // Checks a list of allowable regions against a click location.
  // Returns true if the click should be allowed.
  // Splices out the allowable region from the list after it has been used.
  function checkAllowableRegions(touchCoordinates, x, y) {
    for (var i = 0; i &lt; touchCoordinates.length; i += 2) {
      if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y)) {
        touchCoordinates.splice(i, i + 2);
        return true; // allowable region
      }
    }
    return false; // No allowable region; bust it.
  }

  // Global click handler that prevents the click if it&#x27;s in a bustable zone and preventGhostClick
  // was called recently.
  function onClick(event) {
    if (Date.now() - lastPreventedTime &gt; PREVENT_DURATION) {
      return; // Too old.
    }

    var touches = event.touches &amp;&amp; event.touches.length ? event.touches : [event];
    var x = touches[0].clientX;
    var y = touches[0].clientY;
    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label
    // and on the input element). Depending on the exact browser, this second click we don&#x27;t want
    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label
    // click event
    if (x &lt; 1 &amp;&amp; y &lt; 1) {
      return; // offscreen
    }
    if (lastLabelClickCoordinates &amp;&amp;
        lastLabelClickCoordinates[0] === x &amp;&amp; lastLabelClickCoordinates[1] === y) {
      return; // input click triggered by label click
    }
    // reset label click coordinates on first subsequent click
    if (lastLabelClickCoordinates) {
      lastLabelClickCoordinates = null;
    }
    // remember label click coordinates to prevent click busting of trigger click event on input
    if (event.target.tagName.toLowerCase() === &#x27;label&#x27;) {
      lastLabelClickCoordinates = [x, y];
    }

    // Look for an allowable region containing this click.
    // If we find one, that means it was created by touchstart and not removed by
    // preventGhostClick, so we don&#x27;t bust it.
    if (checkAllowableRegions(touchCoordinates, x, y)) {
      return;
    }

    // If we didn&#x27;t find an allowable region, bust the click.
    event.stopPropagation();
    event.preventDefault();

    // Blur focused form elements
    event.target &amp;&amp; event.target.blur();
  }


  // Global touchstart handler that creates an allowable region for a click event.
  // This allowable region can be removed by preventGhostClick if we want to bust it.
  function onTouchStart(event) {
    var touches = event.touches &amp;&amp; event.touches.length ? event.touches : [event];
    var x = touches[0].clientX;
    var y = touches[0].clientY;
    touchCoordinates.push(x, y);

    $timeout(function() {
      // Remove the allowable region.
      for (var i = 0; i &lt; touchCoordinates.length; i += 2) {
        if (touchCoordinates[i] == x &amp;&amp; touchCoordinates[i + 1] == y) {
          touchCoordinates.splice(i, i + 2);
          return;
        }
      }
    }, PREVENT_DURATION, false);
  }

  // On the first call, attaches some event handlers. Then whenever it gets called, it creates a
  // zone around the touchstart where clicks will get busted.
  function preventGhostClick(x, y) {
    if (!touchCoordinates) {
      $rootElement[0].addEventListener(&#x27;click&#x27;, onClick, true);
      $rootElement[0].addEventListener(&#x27;touchstart&#x27;, onTouchStart, true);
      touchCoordinates = [];
    }

    lastPreventedTime = Date.now();

    checkAllowableRegions(touchCoordinates, x, y);
  }

  // Actual linking function.
  return function(scope, element, attr) {
    var clickHandler = $parse(attr.ngClick),
        tapping = false,
        tapElement,  // Used to blur the element after a tap.
        startTime,   // Used to check if the tap was held too long.
        touchStartX,
        touchStartY;

    function resetState() {
      tapping = false;
      element.removeClass(ACTIVE_CLASS_NAME);
    }

    element.on(&#x27;touchstart&#x27;, function(event) {
      tapping = true;
      tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.
      // Hack for Safari, which can target text nodes instead of containers.
      if (tapElement.nodeType == 3) {
        tapElement = tapElement.parentNode;
      }

      element.addClass(ACTIVE_CLASS_NAME);

      startTime = Date.now();

      var touches = event.touches &amp;&amp; event.touches.length ? event.touches : [event];
      var e = touches[0].originalEvent || touches[0];
      touchStartX = e.clientX;
      touchStartY = e.clientY;
    });

    element.on(&#x27;touchmove&#x27;, function(event) {
      resetState();
    });

    element.on(&#x27;touchcancel&#x27;, function(event) {
      resetState();
    });

    element.on(&#x27;touchend&#x27;, function(event) {
      var diff = Date.now() - startTime;

      var touches = (event.changedTouches &amp;&amp; event.changedTouches.length) ? event.changedTouches :
          ((event.touches &amp;&amp; event.touches.length) ? event.touches : [event]);
      var e = touches[0].originalEvent || touches[0];
      var x = e.clientX;
      var y = e.clientY;
      var dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));

      if (tapping &amp;&amp; diff &lt; TAP_DURATION &amp;&amp; dist &lt; MOVE_TOLERANCE) {
        // Call preventGhostClick so the clickbuster will catch the corresponding click.
        preventGhostClick(x, y);

        // Blur the focused element (the button, probably) before firing the callback.
        // This doesn&#x27;t work perfectly on Android Chrome, but seems to work elsewhere.
        // I couldn&#x27;t get anything to work reliably on Android Chrome.
        if (tapElement) {
          tapElement.blur();
        }

        if (!angular.isDefined(attr.disabled) || attr.disabled === false) {
          element.triggerHandler(&#x27;click&#x27;, [event]);
        }
      }

      resetState();
    });

    // Hack for iOS Safari&#x27;s benefit. It goes searching for onclick handlers and is liable to click
    // something else nearby.
    element.onclick = function(event) { };

    // Actual click handler.
    // There are three different kinds of clicks, only two of which reach this point.
    // - On desktop browsers without touch events, their clicks will always come here.
    // - On mobile browsers, the simulated &quot;fast&quot; click will call this.
    // - But the browser&#x27;s follow-up slow click will be &quot;busted&quot; before it reaches this handler.
    // Therefore it&#x27;s safe to use this directive on both mobile and desktop.
    element.on(&#x27;click&#x27;, function(event, touchend) {
      scope.$apply(function() {
        clickHandler(scope, {$event: (touchend || event)});
      });
    });

    element.on(&#x27;mousedown&#x27;, function(event) {
      element.addClass(ACTIVE_CLASS_NAME);
    });

    element.on(&#x27;mousemove mouseup&#x27;, function(event) {
      element.removeClass(ACTIVE_CLASS_NAME);
    });

  };
}]);

/* global ngTouch: false */

/**
 * @ngdoc directive
 * @name ngSwipeLeft
 *
 * @description
 * Specify custom behavior when an element is swiped to the left on a touchscreen device.
 * A leftward swipe is a quick, right-to-left slide of the finger.
 * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag
 * too.
 *
 * To disable the mouse click and drag functionality, add &#x60;ng-swipe-disable-mouse&#x60; to
 * the &#x60;ng-swipe-left&#x60; or &#x60;ng-swipe-right&#x60; DOM Element.
 *
 * Requires the {@link ngTouch &#x60;ngTouch&#x60;} module to be installed.
 *
 * @element ANY
 * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate
 * upon left swipe. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
    &lt;example module=&quot;ngSwipeLeftExample&quot; deps=&quot;angular-touch.js&quot;&gt;
      &lt;file name=&quot;index.html&quot;&gt;
        &lt;div ng-show=&quot;!showActions&quot; ng-swipe-left=&quot;showActions = true&quot;&gt;
          Some list content, like an email in the inbox
        &lt;/div&gt;
        &lt;div ng-show=&quot;showActions&quot; ng-swipe-right=&quot;showActions = false&quot;&gt;
          &lt;button ng-click=&quot;reply()&quot;&gt;Reply&lt;/button&gt;
          &lt;button ng-click=&quot;delete()&quot;&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
      &lt;/file&gt;
      &lt;file name=&quot;script.js&quot;&gt;
        angular.module(&#x27;ngSwipeLeftExample&#x27;, [&#x27;ngTouch&#x27;]);
      &lt;/file&gt;
    &lt;/example&gt;
 */

/**
 * @ngdoc directive
 * @name ngSwipeRight
 *
 * @description
 * Specify custom behavior when an element is swiped to the right on a touchscreen device.
 * A rightward swipe is a quick, left-to-right slide of the finger.
 * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag
 * too.
 *
 * Requires the {@link ngTouch &#x60;ngTouch&#x60;} module to be installed.
 *
 * @element ANY
 * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate
 * upon right swipe. (Event object is available as &#x60;$event&#x60;)
 *
 * @example
    &lt;example module=&quot;ngSwipeRightExample&quot; deps=&quot;angular-touch.js&quot;&gt;
      &lt;file name=&quot;index.html&quot;&gt;
        &lt;div ng-show=&quot;!showActions&quot; ng-swipe-left=&quot;showActions = true&quot;&gt;
          Some list content, like an email in the inbox
        &lt;/div&gt;
        &lt;div ng-show=&quot;showActions&quot; ng-swipe-right=&quot;showActions = false&quot;&gt;
          &lt;button ng-click=&quot;reply()&quot;&gt;Reply&lt;/button&gt;
          &lt;button ng-click=&quot;delete()&quot;&gt;Delete&lt;/button&gt;
        &lt;/div&gt;
      &lt;/file&gt;
      &lt;file name=&quot;script.js&quot;&gt;
        angular.module(&#x27;ngSwipeRightExample&#x27;, [&#x27;ngTouch&#x27;]);
      &lt;/file&gt;
    &lt;/example&gt;
 */

function makeSwipeDirective(directiveName, direction, eventName) {
  ngTouch.directive(directiveName, [&#x27;$parse&#x27;, &#x27;$swipe&#x27;, function($parse, $swipe) {
    // The maximum vertical delta for a swipe should be less than 75px.
    var MAX_VERTICAL_DISTANCE = 75;
    // Vertical distance should not be more than a fraction of the horizontal distance.
    var MAX_VERTICAL_RATIO = 0.3;
    // At least a 30px lateral motion is necessary for a swipe.
    var MIN_HORIZONTAL_DISTANCE = 30;

    return function(scope, element, attr) {
      var swipeHandler = $parse(attr[directiveName]);

      var startCoords, valid;

      function validSwipe(coords) {
        // Check that it&#x27;s within the coordinates.
        // Absolute vertical distance must be within tolerances.
        // Horizontal distance, we take the current X - the starting X.
        // This is negative for leftward swipes and positive for rightward swipes.
        // After multiplying by the direction (-1 for left, +1 for right), legal swipes
        // (ie. same direction as the directive wants) will have a positive delta and
        // illegal ones a negative delta.
        // Therefore this delta must be positive, and larger than the minimum.
        if (!startCoords) return false;
        var deltaY = Math.abs(coords.y - startCoords.y);
        var deltaX = (coords.x - startCoords.x) * direction;
        return valid &amp;&amp; // Short circuit for already-invalidated swipes.
            deltaY &lt; MAX_VERTICAL_DISTANCE &amp;&amp;
            deltaX &gt; 0 &amp;&amp;
            deltaX &gt; MIN_HORIZONTAL_DISTANCE &amp;&amp;
            deltaY / deltaX &lt; MAX_VERTICAL_RATIO;
      }

      var pointerTypes = [&#x27;touch&#x27;];
      if (!angular.isDefined(attr[&#x27;ngSwipeDisableMouse&#x27;])) {
        pointerTypes.push(&#x27;mouse&#x27;);
      }
      $swipe.bind(element, {
        &#x27;start&#x27;: function(coords, event) {
          startCoords = coords;
          valid = true;
        },
        &#x27;cancel&#x27;: function(event) {
          valid = false;
        },
        &#x27;end&#x27;: function(coords, event) {
          if (validSwipe(coords)) {
            scope.$apply(function() {
              element.triggerHandler(eventName);
              swipeHandler(scope, {$event: event});
            });
          }
        }
      }, pointerTypes);
    };
  }]);
}

// Left is negative X-coordinate, right is positive.
makeSwipeDirective(&#x27;ngSwipeLeft&#x27;, -1, &#x27;swipeleft&#x27;);
makeSwipeDirective(&#x27;ngSwipeRight&#x27;, 1, &#x27;swiperight&#x27;);



})(window, window.angular);

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
